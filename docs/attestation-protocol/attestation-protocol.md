[TOC](../README.md)
# Attestation protocol

**Attestation protocol** is a protocol in which facts from external blockchains, or external data sources in general, are proposed for attestation by users. The set of **default attestation providers** then votes on them by casting their votes in the form of attestations.

In order to understand how the attestation protocol works, lets consider a simplified setting. Here a user proposes to the protocol a fact to be confirmed: that the transaction with the transaction id `XYZ` exists in the Ripple network. Given such an **attestation request**, each attestation provider will first fetch the data about the transaction from the Ripple network. It will extract from the transaction the information like transaction id, block number, block timestamp, source address, destination address, transferred amount, payment reference, etc. The data extracted are collectively called **attestation response**. A 32-byte hash will be produced using the attestation response, serving as the **attestation hash**, or shortly the **attestation**. Such an attestation will be submitted to the protocol. Several attestation providers will do the same in parallel and submit their attestations. The protocol will collect the submitted attestations and if the majority of the attestations are the same, the protocol will confirm the majority attestation hash, yielding the **confirmed attestation hash** (or the **confirmed attestation**).

Then if any user would provide the attestation response data, say to some contract, such a contract could calculate the hash of the attestation response data and compare it to the confirmed attestation hash. In case of a match, the contract would get the confirmation that the provided attestation response data is valid and it can act upon that accordingly.
## A use case

In our example, the transaction with the transaction id `XYZ` in the Ripple network could be a payment for some service managed by a contract on the Flare network, for which one needs to pay 100 XRP to a specific Ripple address. A user would first request the contract for access to the service. The contract would issue a requirement to pay 100 XRP to a specific address given a specific payment reference. The user would then carry out the payment in the Ripple network, producing the payment transaction which, in our example, happens to have the transaction id `XYZ`. Then it would request the attestation protocol to attest for the transaction which would trigger the procedure described above. Once the confirmed attestation hash is obtained by the protocol, the user would submit the attestation data for the transaction `XYZ` to the contract. The contract would check the attestation response data against its requirements (e.g. 100 XRP are required to be sent to the specific receiving address, within the correct time, with the correct payment reference, etc.). Then it would calculate the attestation hash of the provided attestation response data and compare it to the confirmed attestation hash obtained by the attestation protocol. If everything would match, the contract would have the proof that the payment was correct and it could unlock the service for the user.

The simplified version of the attestation protocol described above implies that an efficient implementation of the protocol should be organized as a sequence of voting rounds, where in each voting round attestation providers vote not just on a single attestation request, but on a package of attestation requests. Here we see a clear analogy with the classic part of each blockchain consensus algorithm, where validators try to reach the consensus not just for a single transaction, but for a package of transactions that are accepted in a block. Multiple attestation requests can be collected together and put for a vote in a given voting round. Attestation hashes of all verified attestation response data can be assembled using a Merkle tree into the single hash (the Merkle root) which is submitted by each attestation provider for the voting round. Proving a specific attestation would in this case require a combination of attestation response data, the confirmed attestation hash (the Merkle root) and the specific Merkle proof, obtained for the specific attestation request.

A secure implementation of the protocol should also take care of preventing copying the casted votes (attestations), in a similar manner to how elections are organized. This is achieved by using a proper commit-reveal scheme.

### Commit-reveal scheme

A commit-reveal scheme for voting consists of 2-phase sending of data in such a way that:
- in the commit phase we can send **commit data** that contains the proof of existence of the real data, but does not disclose the data. Sending the commit data is possible only during this phase.
- Once commit phase is finished, reveal phase starts. Here voters can disclose their data (**reveal data**), which should match the **commit data**. Usually the **commit data** is a cryptographic hash of the reveal data. The reveal data typically contain the result of voting (in our case the Merkle root), random number (to mask the Merkle root) and the sender's address (to prevent hash copying).

Note: the current version of the `StateConnector` contract uses a less secure commit reveal scheme which is not copy-proof (no sender address in reveal data).
## The phases of the voting rounds.

The implemented attestation protocol is managed by the [`StateConnector`](state-connector-contract.md) smart contact. Voting activities are organized using sequential **voting windows**, each with 90 seconds duration and enumerated by using the sequential ID - the `bufferNumber`. Each round starts with the particular 90s voting window and its sequential index, and the voting round's `roundId` matches the `bufferNumber` of the voting window. A round evolves through the following four phases, each defined by a 90s voting window:

- `collect` - the first voting window with a given `bufferNumber` that defiines the voting round's `roundId`. In this phase attestation requests are being collected. Once attestation is collected the verification process is started.
- `commit` - the next voting window (`bufferNumber + 1`). In this phase attestation providers are finishing out verifications, calculating the attestations and committing the **commit data** before the end of the phase (submission is performed a certain number of seconds before the window ends, indicated by `attester-config:commitTime` - see the relevant config file `attester-config`). 
Each attestation provider calculates the Merkle root containing only the verified attestations. 
- `reveal` - the next voting window (`bufferNumber + 2`). The attestation providers are revealing their votes by providing the **reveal data** matching to the submitted **commit data** from the previous phase. Note that the **reveal data** is sent together with the **commit data** for the next round (`roundId + 1`).
- `count` - starts immediately after the end of the `reveal` phase, at the beginning of the next voting window (`bufferNumber + 3`). From the reveal data of each attestation provider the submitted Merkle roots are extracted. To verify the validity of the votes, the reveal data is checked against the corresponding commit data for every attestation provider. The protocol then finds the majority Merkle root and declares it as the confirmed attestation (confirmed Merkle root). The majority threshold is set as 50%+ of all possible votes (the set of all default attestation providers is known in advance). In case there is no majority Merkle root, the voting round has failed and no attestation request from that round gets confirmed. Users can resubmit attestation requests in later rounds.


Next: [State connector contract](./state-connector-contract.md)